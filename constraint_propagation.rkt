#lang racket
(define (almost-eq? v1 v2)
  (display "comparing ")
  (display v1)
  (display " with ")
  (display v2)
  (display "\n")
  (cond ((null? v1) (null? v2))
        (else (< (abs (- v1 v2)) .001 ))))
(define (make-connector)
  (let ((value '())
        (setter '())
        (constraints '()))
    
    (define (connect constraint)
      (set! constraints (cons constraint constraints))
      'done)
    
    (define (run-change-handlers)
      (define (loop constraints-left)
        (if (null? constraints-left) 'done
            (begin (((car constraints-left) 'get-change-handler))
                   (loop (cdr constraints-left)))))
      (loop constraints))
    
    (define (set-value! value_ setter_)
      (set! value value_)
      (set! setter setter_)
      (run-change-handlers)
      'done)
    
    (define (dispatch m)
      (cond ((eq? m 'connect) connect)
            ((eq? m 'get-value) value)
            ((eq? m 'get-setter) setter)
            ((eq? m 'set-value!) set-value!)
            (else (error "unknown function"))))
    dispatch))


(define (make-ctr connector-a connector-b connector-c op inv-op)
  ;; a+b=c constraint
  (let ((a connector-a)
        (b connector-b)
        (c connector-c)
        (ops-left 20))
    (define (free-connector? c)
      (let ((v (c 'get-value))
           (s (c 'get-setter))
           (self dispatch)) ;;dispatch is basically the connector that the object
        (or (null? v) (eq? s dispatch))))
    (define (compute)
        (display "computing values")
        ;;values
        (define (get-first-free-connector lst)
          (if (null? lst) (error "can not find a free connector")
              (if (free-connector? (car lst)) (car lst) (get-first-free-connector (cdr lst)))))
        
        (define (count-free-connectors connectors)
          (if (null? connectors) 0
              (if (free-connector? (car connectors)) (+ 1 (count-free-connectors (cdr connectors)))
                                                                (count-free-connectors (cdr connectors)))))
        (define (set-all-free-connectors-to-null)
          (define (loop connectors-left)
            (if (null? connectors-left) 'done
                (let ((head (car connectors-left))
                      (self dispatch))
                  (if (and (free-connector? head) (not (null? (head 'get-value))))
                           ((head 'set-value!) '() self) 'skip)
                           (loop (cdr connectors-left)))))
          (loop (list a b c)))
        (let ((nb-free-connectors (count-free-connectors (list a b c)))
              (self dispatch))
             (if (= nb-free-connectors 1)
                  (let ((a-free? (free-connector? a))
                        (b-free? (free-connector? b))
                        (c-free? (free-connector? c)))
                    (define (set-connector! c v)
                      (if (almost-eq? (c 'get-value) v) 'nothing-to-do
                                               ((c 'set-value!) v self)))
                    (cond (a-free? (set-connector! a (inv-op (c 'get-value) (b 'get-value))))
                          (b-free? (set-connector! b (inv-op (c 'get-value) (a 'get-value))))
                          (c-free? (set-connector! c (op (a 'get-value) (b 'get-value))))
                          (else (error "something fishy happened, you should have at least one free connector"))))
                 (set-all-free-connectors-to-null))))
          
    (define (refresh)
      (if (<= ops-left 0) 'too-many-ops
          (begin (set! ops-left (- ops-left 1))
                 (compute))))
    (define (dispatch m)
      (cond ((eq? m 'get-change-handler) refresh)
             (else (error "Adder: Unknown function"))))
    ((a 'connect) dispatch)
    ((b 'connect) dispatch)
    ((c 'connect) dispatch)
    (compute)
    dispatch))

(define (set-value! connector value)
  ((connector 'set-value!) value 'user))
(define (get-value connector)
  (connector 'get-value))
(define (make-adder a b c)
  (make-ctr a b c + -))
(define (make-multiplier a b c)
  (make-ctr a b c * /))
(define (make-multiplier-dec a b c)
  (make-ctr a b c * (lambda (a b) (/ (* 1.0 a) b))))

(define (c+ a b)
  (define c (make-connector))
  (make-adder a b c)
  c)
(define (c* a b)
  (define c (make-connector))
  (make-multiplier a b c)
  c)

(define (cv v)
  (define c (make-connector))
  (set-value! c v)
  c)


;; tests
(define (celsius-farenheit-converter c f)
  (define nine (make-connector))
  (set-value! nine 9)
  (define five (make-connector))
  (set-value! five 5)
  (define tw (make-connector))
  (set-value! tw 32)
  (define inter (make-connector))
  (define inter2 (make-connector))
  (define m1 (make-multiplier-dec c nine inter))
  (define m2 (make-multiplier-dec five inter2 inter))
  (define adder (make-adder inter2 tw f))
  'done)


(define (average a b avr)
  (define two (make-connector))
  (set-value! two 2)
  (define a+b (make-connector))
  (make-adder a b a+b)
  (make-multiplier avr two a+b)
  'done)
(define (squarer a b)
  (make-multiplier a a b))
(define a (make-connector))
(define b (make-connector))
(set-value! b 9)
(squarer a b)
(get-value a)

(define sum (c+ (c* (cv 2) (cv 5)) (cv 2)))
(get-value sum)