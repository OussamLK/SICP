#lang racket
(define (make-wire)
  (let ((signal 0)
        (run-on-update '()) ;a list of functions to be ran when the value changes
        )
    (define (run-updates)
      (define (loop update-functions)
        (if (null? update-functions) 'update-ran
            (begin ((car update-functions)) (loop (cdr update-functions)))))
      (loop run-on-update))
    (define (register-update-function! f)
      (set! run-on-update (cons f run-on-update)))
    (define (get-signal) signal)
    (define (set-signal! value)
      (set! signal value)
      (run-updates)
      )
    (define (dispatch m)
      (cond ((eq? m 'get-signal) (get-signal))
            ((eq? m 'set-signal!) set-signal!)
            ((eq? m 'register-update-function!) register-update-function!)
            (else (error "unknown function"))))
    dispatch
    ))

(define (set-action! wire fun)
  ;fun should have arity 0, this sounds like a bad design choice...
  ((wire 'register-update-function!) fun))

(define (after-delay delay-sec f)
  ;;(display "sleeping for ") (display delay-sec) (display " seconds...\n")
  (f))



(define (make-and-gate in1 in2 out)
  (define and-delay 1)
  (define (band v1 v2)
    (if (and (= v1 1) (= v2 1)) 1 0))
  (define (delayed-update)
    (let ((new-output (band (in1 'get-signal) (in2 'get-signal))))
      (after-delay and-delay (lambda () ((out 'set-signal!) new-output)))))
  (delayed-update) ;;set the output on creation
  (set-action! in1 delayed-update)
  (set-action! in2 delayed-update))

(define (make-not-gate in out)
  (define not-delay 0.5)
  (define (bnot in)
    (if (= 0 in) 1 0))
  (define (delayed-update)
    (let ((new-output (bnot (in 'get-signal))))
      (after-delay not-delay (lambda () ((out 'set-signal!) new-output)))))
  (delayed-update)
  (set-action! in delayed-update))

(define (make-or-gate in1 in2 out)
  (let ((w1 (make-wire))
        (w2 (make-wire))
        (w3 (make-wire)))
     (make-not-gate in1 w1)
     (make-not-gate in2 w2)
     (make-and-gate w1 w2 w3)
     (make-not-gate w3 out)
      'done
      ))

(define (make-nand-gate in1 in2 out)
  (let ((w1 (make-wire)))
    (make-and-gate in1 in2 w1)
          (make-not-gate w1 out))
      'done)

(define (make-xor-gate in1 in2 out)
  (let ((w1 (make-wire))
        (w2 (make-wire)))
    (make-or-gate in1 in2 w1)
    (make-nand-gate in1 in2 w2)
    (make-and-gate w1 w2 out)
    'done))

(define (make-half-adder a b s c)
  (make-xor-gate a b s)
  (make-and-gate a b c))
  
(define (make-full-adder c0 a b s c)
  (let ((s1 (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (make-half-adder c0 a s1 c1)
    (make-half-adder s1 b s c2)
    (make-or-gate c1 c2 c)
    'done-full-adding))

(define ZERO_WIRE (make-wire))
(define (MAKE_ONE_WIRE)
  (let ((w (make-wire)))
    ((w 'set-signal!) 1)
    w)
    )

(define (ripple-adder a b r c)
  (if (null? a) ((c 'set-signal!) 0)
      (let ((w1 (make-wire)))
        (ripple-adder (cdr a) (cdr b) (cdr r) w1)
          (make-full-adder w1 (car a) (car b) (car r) c)))      
      )

(define A (list (MAKE_ONE_WIRE) (MAKE_ONE_WIRE)))
(define B (list ZERO_WIRE (MAKE_ONE_WIRE)))
(define c (make-wire))
(define R (list (make-wire) (make-wire)))
(define (pp-wire-list lst)
  (if (null? lst) '()
      (cons ((car lst) 'get-signal)
            (pp-wire-list (cdr lst)))))

(ripple-adder A B R c)
(pp-wire-list R)
(c 'get-signal)
