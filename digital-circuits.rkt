#lang racket
(define (make-wire)
  (let ((signal 0)
        (run-on-update '()) ;a list of functions to be ran when the value changes
        )
    (define (run-updates)
      (define (loop update-functions)
        (if (null? update-functions) 'update-ran
            (begin ((car update-functions)) (loop (cdr update-functions)))))
      (loop run-on-update))
    (define (register-update-function! f)
      (set! run-on-update (cons f run-on-update)))
    (define (get-signal) signal)
    (define (set-signal! value)
      (set! signal value)
      (run-updates)
      )
    (define (dispatch m)
      (cond ((eq? m 'get-signal) (get-signal))
            ((eq? m 'set-signal!) set-signal!)
            ((eq? m 'register-update-function!) register-update-function!)
            (else (error "unknown function"))))
    dispatch
    ))

(define (set-action! wire fun)
  ;fun should have arity 0, this sounds like a bad design choice...
  ((wire 'register-update-function!) fun))

(define (after-delay delay-sec f)
  ;;(display "sleeping for ") (display delay-sec) (display " seconds...\n")
  (f))



(define (make-and-gate in1 in2 out)
  (define and-delay 1)
  (define (band v1 v2)
    (if (and (= v1 1) (= v2 1)) 1 0))
  (define (delayed-update)
    (let ((new-output (band (in1 'get-signal) (in2 'get-signal))))
      (after-delay and-delay (lambda () ((out 'set-signal!) new-output)))))
  (delayed-update) ;;set the output on creation
  (set-action! in1 delayed-update)
  (set-action! in2 delayed-update))

(define (make-not-gate in out)
  (define not-delay 0.5)
  (define (bnot in)
    (if (= 0 in) 1 0))
  (define (delayed-update)
    (let ((new-output (bnot (in 'get-signal))))
      (after-delay not-delay (lambda () ((out 'set-signal!) new-output)))))
  (delayed-update)
  (set-action! in delayed-update))

(define (make-or-gate in1 in2 out)
  (let ((w1 (make-wire))
        (w2 (make-wire))
        (w3 (make-wire)))
     (make-not-gate in1 w1)
     (make-not-gate in2 w2)
     (make-and-gate w1 w2 w3)
     (make-not-gate w3 out)
      'done
      ))

(define (make-nand-gate in1 in2 out)
  (let ((w1 (make-wire)))
    (make-and-gate in1 in2 w1)
          (make-not-gate w1 out))
      'done)

(define (make-xor-gate in1 in2 out)
  (let ((w1 (make-wire))
        (w2 (make-wire)))
    (make-or-gate in1 in2 w1)
    (make-nand-gate in1 in2 w2)
    (make-and-gate w1 w2 out)
    'done))

(define (make-half-adder a b s c)
  (make-xor-gate a b s)
  (make-and-gate a b c))
  
(define (make-full-adder c0 a b s c)
  (let ((s1 (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (make-half-adder c0 a s1 c1)
    (make-half-adder s1 b s c2)
    (make-or-gate c1 c2 c)
    'done-full-adding))



(define a (make-wire))
(define b (make-wire))
(define c0 (make-wire))
(define s (make-wire))
(define c (make-wire))
(make-full-adder c0 a b s c)

(define (pprint-result)
  (let ((sv (s 'get-signal))
        (cv (c 'get-signal)))
    (display "----sum is ")
    (display sv)
    (display " carry is ")
    (display cv)
    (display "\n")))

(s 'get-signal)
(c 'get-signal)
(pprint-result)
((a 'set-signal!) 1)
(pprint-result)
((b 'set-signal!) 1)
(pprint-result)
((c0 'set-signal!) 1)
(pprint-result)