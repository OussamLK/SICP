#lang racket/base
(define (list-eq? l1 l2)
    (define (both-null a b) (and (null? a ) (null? b)))
    (define (not-null a) (not(null? a)))
    (define (none-null a b) (and (not-null a) (not-null b)))
    (or (both-null l1 l2)
        (and (none-null l1 l2)
             (and (eq? (car l1) (car l2))
                (list-eq? (cdr l1) (cdr l2))
                )
             )
        )
    )

(define (get-op-name row) (car row))
(define (op-types row) (caddr row))
(define (make-row op-name op . op-types) (list op-name op op-types))
(define (get-op-row op-name types-list table)
        (define (found-op? op types-list row)
            (and (eq? (get-op-name row) op)
                 (list-eq? (op-types row) types-list))
        )
        (if (null? table) '()
                          (if (found-op? op-name types-list (car table))
                                (car table)
                                (get-op-row op-name types-list (cdr table))
            )
        )
)

(define (install-rational-numbers old-table)
        (define (make a b) (list a b))
        (define (num n) (car n))
        (define (denom n) (cadr n))
        (define (add a b)
            (let ((new-denom (* (denom a) (denom b)))
                 (left-num (*(num a) (denom b)))
                 (right-num (* (num b) (denom a))))
                    (make (+ left-num right-num) new-denom)
                 )
            )
        ;; interface to the rest
        (define (tag n) (cons 'rational n))
        (define (untag n) (cdr n))
        (define (make-rat a b) (tag (make a b)))
        (define (add-rat a b) (tag (apply add (map untag (list a b)))))        
        (let ((package (list (make-row 'make make-rat  'rational)
                             (make-row 'add add-rat 'rational 'rational))))
             (append package old-table))
        )
(define (install-nat-numbers old-table)
        (define (make a) a)
        (define (add a b)
            (+ a b)
            )
        ;; interface to the rest
        (define (tag n) (list 'natural n))
        (define (untag n) (cadr n))
        (define (make-nat a) (tag (make a)))
        (define (add-nat a b) (tag (apply add (map untag (list a b)))))        
        (let ((package (list (make-row 'make make-nat  'natural)
                             (make-row 'add add-nat 'natural 'natural))))
             (append package old-table))
        )
(define op-table (install-rational-numbers '()))
(define op-table2 (install-nat-numbers op-table))

(define (generic-op op op-table args)
    (define types (map car args))
    (define conc-op (get-op-row op types op-table))
    (apply (cadr conc-op) args)
)

(define make-nat (cadr (get-op-row 'make '(natural) op-table2)))
(define make-rat (cadr (get-op-row 'make '(rational) op-table2)))
(define (add . args) (generic-op 'add op-table2 args))
(define n1 (make-nat 1))
(define q1 (make-rat 1 2))
(add n1 n1)




